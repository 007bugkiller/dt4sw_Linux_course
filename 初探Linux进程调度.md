- [初探Linux进程调度](#初探linux进程调度)
  - [Linux的进程调度](#linux的进程调度)
    - [进程调度原理](#进程调度原理)
    - [Linux系统调度策略](#linux系统调度策略)
  - [进程调度实验](#进程调度实验)
    - [改变/获取调度策略](#改变获取调度策略)

# 初探Linux进程调度

已知  
* 父进程创建子进程后, 父子进程同时运行
问题  
* 如果计算机只有一个处理器, 父子进程以什么方式同时执行

## Linux的进程调度

* 内核具有进程调度能力, 多个进程可同时进行
* 微观上, 处理器同一时刻只能执行一个进程
* 同时运行多个进程时, 每个进程都会获得适当的执行时间片
* 当执行时间片用完，内核会调度下一个进程执行

### 进程调度原理

* n个进程同时位于内存中
* 处理器执行进程，每个进程拥有一个时间片
* 时间片用完，通过中断完成进程切换

伪代码如下:  
```C
void schedule()
{
    currentTask = taskList.getNext();

    prepare4Next(currentTask);

    loadTask(currentTask);
}
```

### Linux系统调度策略

* SCHED_OTHER： Linux的默认调度策略 即CFS(完全公平调度)，给每个进程动态计算优先级，根据优先级和进程执行历史记录确定下一个运行进程
* SCHED_FIFO：基于优先级顺序调度进程，只要一个进程获得CPU后就一直执行直到进程主动释放
* SCHED_RR：基于**时间片轮转**的调度策略，给每个进程设置一个固定时间片，并按照优先级顺序对进程进行轮流调度

## 进程调度实验

### 改变/获取调度策略

```chrt```命令:  

```
chrt [选项] <优先级> <命令> [<参数>...]

策略选项：
 -b, --batch          将策略设置为 SCHED_BATCH
 -d, --deadline       将策略设置为 SCHED_DEADLINE
 -f, --fifo           将策略设置为 SCHED_FIFO
 -i, --idle           将策略设置为 SCHED_IDLE
 -o, --other          将策略设置为 SCHED_OTHER
 -r, --rr             将策略设置为 SCHED_RR (默认)

 其他选项：
 -a, --all-tasks      对指定 pid 的所有任务(线程) 操作
 -m, --max            显示最小和最大有效优先级
 -p, --pid            对指定且存在的 pid 操作
 -v, --verbose        显示状态信息
```

实验运行结果 略...

